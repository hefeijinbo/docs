Windows 系统架构

# 整体架构图
![Alt text](%E6%8D%95%E8%8E%B7.PNG)
用户模式包含如下组件
### 用户进程
分为
- 16位进程(Windows 3.1, MS-ODS)
- 32位进程
- 64位进程
### 服务进程
承载了Windows服务,如Task Scheduler和Print Spooler服务
### 系统进程
静态或硬编码的进程,例如非Windows服务进程的登录进程和会话管理器。也就是说,这些进程并非由服务控制管理器启动。
### 环境子系统服务器进程
实现了操作系统系统环境支持部分
### 子系统DLL和NTDLL.DLL
服务进程和用户进程无法直接调用原生的Windows操作系统服务, 通过一个或多个子系统动态链接库(DLL),再通过Ntdll.dll完成调用

Windows内核模式有如下组件
### 执行体
操作系统基础服务, 如内存管理,进程和线程管理,安全性,I/O,网络以及进程间通信
### Windows内核
包含操作系统函数,例如线程调度,中断和异常分发,多处理器同步,内核还提供了一系列例程和基本对象
### 设备驱动程序
将用户I/O函数调用转换成特定硬件设备I/O请求的硬件设备驱动程序,以及文件系统和网络驱动程序等非硬件设备驱动程序
### 硬件抽象层(HAL)
负责将内核,设备驱动程序以及执行体与具体平台相关差异(例如不同主板)进行隔离
### 窗口和图形系统
实现用户界面(GUI)功能
### 虚拟机监控程序层

如下是Windows核心组件的文件名

- Ntoskrnl.exe: 执行体和内核
- Hail.dll: HAL
- Win32k.sys: Windoes子系统的内核模式部分(GUI)
- /SystemRoot/System32/Drivers 下的.sys文件: 核心驱动程序,如Direct X,卷管理器,TCP/IP,TPM和ACPI支持
- Ntdll.dll: 内部支持函数
- Kernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll:核心Windows子系统DLL

# 可移植性
Windows 支持在多种架构的硬件上运行,包含 x86, x86-64,  ARM, ARM64, MIPS, PowerPC

如何做到跨平台可移植

1. 分层式设计

    与处理器有关的(平台相关的)底层会被隔离到独立的模块,上层就无需考虑不同体系架构和硬件平台的差异了。通过HAL来进行隔离

2. 使用C语言

    Windows 大部分代码通过C语言编写,少部分使用C++,保证了在各个系统的可移植性

# 可伸缩性
多处理器系统中的资源争用和性能问题比较复杂,Window通过如下方面解决伸缩性问题
多处理器系统下，管家你的问题是可伸缩性。windows有以下功能这些功能对windows作为一个多处理器起到关键性的作用：
1. 在任何处理器, 以及多颗处理器上运行操作系统的能力
2. 在单个进程内执行多个线程,每个线程可以用不同处理器并发执行的能力
3. 内核中进行细粒度同步(自旋锁,队列中的自旋锁,推锁),在设备驱动程序和服务器进程内部进行细粒度同步,让更多组件可以在多颗处理器上并发运行
4. I/O完成端口
这些琐事提高了伸缩性

# 客户和服务器版本的区别
客户版和服务器版主要区别是有：

支持的处理器个数不同。

支持的物理内存不同。

所支持的并发网络连接数不同。
# 设备驱动程序

设备驱动程序是可加载的内核模式(以.sys结尾),他们在I/O管理器和相应的硬件之间建立链接。驱动在内核模式下，位于以下3个环境之一：

1.在发起I/O功能的用户线程环境中

2.在内核模式系统线程的环境中

3.作为一个中断的结果(因此不存在任何特定的进程或者线程执行环境中)

驱动也是调用HAL，因此驱动程序可以在windows支持的cpu体系结构上代码级移植，在同一个体系结构族内是二进制可移植的。

设备驱动有以下几类：

1.硬件设备驱动程序，通过HAL操作硬件，从而输出到设备或者网络，或者从设备或者网络中输入。硬件设备驱动也有很多类型如，总线驱动，人机界面驱动等。

2.文件系统驱动程序是指可以接受面向文件的I/O请求，并将这些请求转化成针对某一特定设备的I/O请求。

3.文件系统过滤器驱动程序：如截取了I/O请求并且执行某些增值处理之后再传递给下一层驱动(执行磁盘镜像，加密的驱动程序)。

4.网络重定向器和服务器指文件系统I/O请求传递给网络上的某一台机器。或者从网络上接收此类请求的文件系统驱动程序。

5.协议驱动程序，如TCP/IP,NetBEUI,IPX/SPX之类的网络协议

6.内核流式过滤器驱动程序：这样的驱动被串接起来，以便对流数据进行信号处理。

驱动程序是内核模式中添加代码的唯一方式。

2.4.9 系统进程
以下系统进程会出现在每个windows系统中(其中空闲进程，system进程并不是完整的过程，因为它们不是运行在用户模式的可执行文件):

1.空闲进程

2.system进程

3.会话管理器(smss.exe)

4.windows子系统(csrss.exe)

5.登陆进程(winlogon.exe)

6.服务控制管理器(services.exe)和它创建的子服务进程(如系统提供通用服务宿主进程svrhost.exe)

7.本地安全认证服务器(lsass.exe)

2.4.9.1 空闲进程
空闲进程是第一个进程，并没有在用户模式下的实际映像文件。

2.4.9.2 中断和DPC
标记为中断和DPC(分发过程调用)用于中断和延迟过程调用的时间，他们并不是进程，列在这里是因为他们都会消耗cpu，并没有计算在任何一个进程中，而是被算在系统空闲中。

2.4.9.3 system进程和系统进程
system进程是一种特殊线程的母体。这些特殊线程只能运行在内核模式哦。系统线程有普通线程所有属性和环境，但是只运行系统空间中加载的代码。系统线程没有地址空间，因此动态存储空间，都必须从系统中内存堆分配，比如换页或者非换页池。

系统线程是由PsCreateSystemThread来创建的，这个函数只能在内核环境下才能被调用。

内核会创建一个称为平衡集管理器的系统线程，每秒没唤醒一次，可能发出调度和内存管理相关事件。告诉缓存管理器也使用系统线程来实现“预读”和”延迟写”功能。

在排查问题是，知道系统线程映射到某个驱动程序中，甚至映射到包含改代码的子例程中，一定非常有用。

所以如果system进程中的线程正在运行，首先要确定哪些线程在运行。通过线程看哪个驱动开始的或者检查调用栈，得知在运行到哪里了。

2.4.9.4 会话管理器
会话管理器(smss.exe)是系统中第一个创建的用户模式进程，由负责完成执行体和内核初始化工作的内核模式系统线程最后创建实际的smss.exe进程。

在windows启动过程中，会话管理器负责许多比较重要的步骤，如打开页面文件，执行延迟文件改名，删除操作，创建环境变量。将子系统程序(csrss.exe)和winlogon.exe启动起来。winlogon进程依次启动其他系统进程。

smss.exe的主线程执行以上步骤后，一直在csrss.exe和winlogon的进程上等待。如果这2个进程中任何一个非正常终止了，则ssms.exe让系统崩溃，(崩溃代码：status_system_process_terminated或0xc000021a)因为windows依赖这2个进程才能运行。

 

smss等待加载子系统的请求，调式事件，以创建新的终端服务器会话的请求。

终端服务会话是由smss来完成的。当smss接到一个创建会话的请求时，先调用NtSetSystemInformation,请求建立内核模式数据结构。又调用内部的内存管理函数MmSessionCreate该函数建立起会话虚拟地址空间，改地址空间包含会话中的换页池以及由win32子系统的内核模式部分和其他的会话空间设备驱动程序所分配，属于某个会话的数据结构，然后会为该会话创建winlogon和csrss实例。

 